// Copyright (c) 2015, the Dart Team. All rights reserved. Use of this
// source code is governed by a BSD-style license that can be found in
// the LICENSE file.

// This file was generated by the transformer in package:reflectable
// based on the template file reflectable_.dart. Do not edit.

library %REFLECTABLE_TEMPLATE_LIBRARY%;

/// Import the interface that this library implements and the default
/// implementation of static mirror classes.
import 'package:reflectable/mirrors.dart';
import 'package:reflectable/src/mirrors_unimpl.dart';

/// Import all the classes that have Reflectable in their metadata.
%REFLECTABLE_TEMPLATE_TARGET_CLASS_LIBRARY_IMPORTS%

/// Maps a [Symbol] to a [LibraryMirror] for that library.
final Map<Symbol, LibraryMirror>  _reflectLibraryMap = {
  _reflectable_LibrarySymbol: _reflectable_LibraryMirror,
  _core_LibrarySymbol: _core_LibraryMirror,
  %REFLECTABLE_TEMPLATE_LIBRARY_MAPPINGS%
};

/// Symbols used by _reflectLibraryMap.
const _reflectable_LibrarySymbol = const Symbol('reflectable.reflectable');
const _core_LibrarySymbol = const Symbol('dart.core');
%REFLECTABLE_TEMPLATE_LIBRARY_SYMBOLS%

/// Objects used by _reflectLibraryMap.
final _reflectable_LibraryMirror = new _reflectable_LibraryMirrorImpl();
final _core_LibraryMirror = new _core_LibraryMirrorImpl();
%REFLECTABLE_TEMPLATE_LIBRARIES%

/// Maps a [Type] which denotes a reflectable class to a [ClassMirror]
/// of that class.
final Map<Type, ClassMirror> _reflectClassMap = {
  Object: new _Object_ClassMirrorImpl(),
  int: new _int_ClassMirrorImpl(),
  %REFLECTABLE_TEMPLATE_CLASS_MAPPINGS%
};

typedef InstanceMirror InstanceMirrorProducer(Object);

/// Maps a Type to a factory for a mirror for an instance of that Type.
final Map<Type, InstanceMirrorProducer> _reflectMap = {
  Object: (o) => new _Object_InstanceMirrorImpl(o),
  %REFLECTABLE_TEMPLATE_INSTANCE_MIRROR_PRODUCERS%
};

/// General, static version of the class Reflectable.  Note that it
/// needs to be part of the template because it relies on generated
/// entities, and they cannot be virtual across libraries.
class Reflectable {
  final List<Capability> capabilities;

  const Reflectable(this.capabilities);

  LibraryMirror findLibrary(Symbol libraryName) {
    return _reflectLibraryMap[libraryName];
  }

  ClassMirror reflectClass(Type type) {
    return _reflectClassMap[type];
  }

  ClassMirror reflectType(Type type) {
    return _reflectTypeMap[type];
  }

  InstanceMirror reflect(object) {
    if (object is Type) return new _Type_InstanceMirrorImpl(object);
    return _reflectMap[object.runtimeType](object);
  }
}

// Generated static mirror classes.
// --------------------------------

%REFLECTABLE_TEMPLATE_STATIC_MIRROR_CLASSES%
